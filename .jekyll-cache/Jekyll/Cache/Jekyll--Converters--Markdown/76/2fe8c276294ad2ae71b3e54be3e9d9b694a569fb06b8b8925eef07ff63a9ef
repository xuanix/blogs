I"1,<h1>Object-Oriented Programming</h1>
<hr />

<h2>Introduction</h2>

<pre><code>class Car(objecct):
    num_wheels = 4

    def __init__(self, color):
        self.wheels = Car.num_wheels
        self.color = color

    def drive(self):
        if self.wheels &lt;= Car.num_wheels:
            return self.color + ' car cannot drive!'
        return self.color + ' car goes vroom!'

    def pop_tire(self):
        if self.wheels &gt; 0:
            self.wheels -= 1
</code></pre>

<ul>
  <li><strong>class</strong>: a blueprint for how to build a certain type of object. In example, <code>Car</code>.</li>
  <li><strong>instance</strong>: a particular occurrence of a class. <br /> <code>my_car = Car('red')</code></li>
  <li><strong>attribute</strong> or <strong>field</strong>: a variable that belongs to the class. Think of an attribute as a <em>quality</em> of the object. We can access attributes using <strong>dot notation</strong>.</li>
  <li><strong>method</strong>: Mthods are just like normal functions, except that they are tied to an instance or a class. Think of a method as a “verb” of a class: cars can <em>drive</em> and also <em>pop their tires</em>. We can call methods using <strong>dot notation</strong>.</li>
  <li><strong>constructor</strong>: As with data abstraction, constructors describe how to build an instance of the class. Most classes have a constructor. In Python, the constructor of the class defined as <code>__init__</code>.</li>
  <li><code>self</code>: in Python, <code>self</code> is the first parameter for many methods. When a method is called, <code>self</code> is bound to an instance of the class. The dot notation <strong>implicitly</strong> passes in instance as <code>self</code> for us.</li>
</ul>

<h3>Types of variables</h3>
<ul>
  <li><strong>local variable</strong>: These are just like the variables you see in normal functions - once the function or method is done being called, this variable is no longer able to be accessed.</li>
  <li><strong>instance attribute</strong>: Unlike local variables, instance attributes will still be accessible after method calls have finished. Each instance of a class keeps its own version of the instance attribute.</li>
  <li><strong>class attribute</strong>: As with instance attributes, class attributes also persist across method calls. However, unlike instance attributes, all instances of a class will share the same class attributes.</li>
</ul>

<h3>Question 1</h3>
<pre><code>&gt;&gt;&gt; class Account(object):
...     interest = 0.02
...     def __init__(self, account_holder):
...         self.balance = 0
...         self.holder = account_holder
...     def deposit(self, amount):
...         self.balance = self.balance + amount
...         print("Yes!")
...
&gt;&gt;&gt; a = Account("Billy")
&gt;&gt;&gt; a.account_holder
AttributeError: 'Account' object has no attribute 'account_holder'

&gt;&gt;&gt; a.holder
'Billy'

&gt;&gt;&gt; Account.holder
AttributeError: type object 'Account' has no attribute 'holder'

&gt;&gt;&gt; Account.interest
0.02

&gt;&gt;&gt; a.interest
0.02

&gt;&gt;&gt; Account.interest = 0.03
&gt;&gt;&gt; a.interest
0.03

&gt;&gt;&gt; a.deposit(1000)
'Yes!'

&gt;&gt;&gt; a.balance
1000

&gt;&gt;&gt; a.interest = 9001
&gt;&gt;&gt; Account.interest
0.03
</code></pre>

<h3>Question 2</h3>
<pre><code>class Person(object):
    """Person class.

    &gt;&gt;&gt; steven = Person("Steven")
    &gt;&gt;&gt; steven.repeat()       # starts at whatever value you'd like
    'I squirreled it away before it could catch on fire.'
    &gt;&gt;&gt; steven.say("Hello")
    'Hello'
    &gt;&gt;&gt; steven.repeat()
    'Hello'
    &gt;&gt;&gt; steven.greet()
    'Hello, my name is Steven'
    &gt;&gt;&gt; steven.repeat()
    'Hello, my name is Steven'
    &gt;&gt;&gt; steven.ask("preserve abstraction barriers")
    'Would you please preserve abstraction barriers'
    &gt;&gt;&gt; steven.repeat()
    'Would you please preserve abstraction barriers'
    """
    def __init__(self, name):
        self.name = name
        self.last = 'I squirreled it away before it could catch on fire.'

    def say(self, stuff):
        self.last = stuff
        return stuff

    def ask(self, stuff):
        return self.say("Would you please " + stuff)

    def greet(self):
        return self.say("Hello, my name is " + self.name)

    def repeat(self):
        return self.last
</code></pre>

<h3>Question 3</h3>
<pre><code>class Account(object):
    """A bank account that allows deposits and withdrawals.

    &gt;&gt;&gt; eric_account = Account('Eric')
    &gt;&gt;&gt; eric_account.deposit(1000000)   # depositing my paycheck for the week
    1000000
    &gt;&gt;&gt; eric_account.transactions
    [('deposit', 1000000)]
    &gt;&gt;&gt; eric_account.withdraw(100)      # buying dinner
    999900
    &gt;&gt;&gt; eric_account.transactions
    [('deposit', 1000000), ('withdraw', 100)]
    """

    interest = 0.02

    def __init__(self, account_holder):
        self.balance = 0
        self.holder = account_holder
        self.transactions = []

    def deposit(self, amount):
        """Increase the account balance by amount and return the
        new balance.
        """
        self.transactions.append(('deposit', amount))
        self.balance = self.balance + amount
        return self.balance

    def withdraw(self, amount):
        """Decrease the account balance by amount and return the
        new balance.
        """
        if amount &gt; self.balance:
            return 'Insufficient funds'
        self.transactions.append(('withdraw', amount))
        self.balance = self.balance - amount
        return self.balance</code></pre>

<h2>Property Decorator</h2>
<p><code>@property</code> decorator allows us to call a <em>zero-argument method</em> without adding parentheses, instead, like an instance attribute.</p>

<h3>Question 4</h3>
<pre><code>class BadBankAccount(Account):
    """ A subclass of bank account that allows an account holder to overdraw
    once, and then prevents them from withdrawing more money. You should also
    implement the property method overdrawn, which allows an account holder to
    check if they are overdrawn.

    &gt;&gt;&gt; harold_account = BadBankAccount('Harold')
    &gt;&gt;&gt; harold_account.deposit(100)   # depositing my paycheck for the week
    100
    &gt;&gt;&gt; harold_account.withdraw(101)  # buying dinner
    -1
    &gt;&gt;&gt; harold_account.overdrawn
    True
    &gt;&gt;&gt; harold_account.withdraw(100000)
    You have overdrawn, please add more money!
    -1
    &gt;&gt;&gt; harold_account.deposit(10)
    9
    &gt;&gt;&gt; harold_account.overdrawn
    False
    """

    def withdraw(self, amount):
        """Decrease the account balance by amount and return the
        new balance.
        """
        if self.balance &lt; 0:
            print('You have overdrawn, please add more money!')
            return self.balance
        self.balance = self.balance - amount
        return self.balance

    @property
    def overdrawn(self):
        return self.balance &lt; 0</code></pre>

<h2>Inheritance</h2>
<hr />

<h3>Question 5</h3>
<pre><code>&gt;&gt;&gt; class Account(object):
...     interest = 0.02
...     def __init__(self, account_holder):
...         self.balance = 0
...         self.holder = account_holder
...     def deposit(self, amount):
...         self.balance = self.balance + amount
...         print("Yes!")
...
&gt;&gt;&gt; class CheckingAccount(Account):
...     def __init__(self, account_holder):
...         Account.__init__(self, account_holder)
...     def deposit(self, amount):
...         Account.deposit(self, amount)
...         print("Have a nice day!")
...
&gt;&gt;&gt; a = Account("Billy")
&gt;&gt;&gt; a.balance
0

&gt;&gt;&gt; c = CheckingAccount("Eric")
&gt;&gt;&gt; c.balance
0

&gt;&gt;&gt; a.deposit(30)
'Yes!'

&gt;&gt;&gt; c.deposit(30)
'Yes!'
'Have a nice day!'

&gt;&gt;&gt; c.interest
0.02

</code></pre>

<h3>Question 6</h3>
<pre><code>class DoubleTalker(Person):
    def __init__(self, name):
        Person.__init__(self, name)
    def say(self, stuff):
        return Person.say(self, stuff) + " " + self.repeat()

class DoubleTalker(Person):
    def __init__(self, name):
        Person.__init__(self, name)
    def say(self, stuff):
        return stuff + " " + stuff

class DoubleTalker(Person):
    def __init__(self, name):
        Person.__init__(self, name)
    def say(self, stuff):
        return Person.say(self, stuff + " " + stuff)</code></pre>

<p>Last one works as intended. For the fist and second, <code>repeat</code> method would fail.</p>

<h3>Question 7</h3>
<pre><code>class CheckingAccount(Account):
    """A bank account that charges for withdrawals.

    &gt;&gt;&gt; check = Check("Steven", 42)  # 42 dollars, payable to Steven
    &gt;&gt;&gt; steven_account = CheckingAccount("Steven")
    &gt;&gt;&gt; eric_account = CheckingAccount("Eric")
    &gt;&gt;&gt; eric_account.deposit_check(check)  # trying to steal steven's money
    The police have been notified.
    &gt;&gt;&gt; eric_account.balance
    0
    &gt;&gt;&gt; check.deposited
    False
    &gt;&gt;&gt; steven_account.balance
    0
    &gt;&gt;&gt; steven_account.deposit_check(check)
    42
    &gt;&gt;&gt; check.deposited
    True
    &gt;&gt;&gt; steven_account.deposit_check(check)  # can't cash check twice
    The police have been notified.
    """
    withdraw_fee = 1
    interest = 0.01

    def withdraw(self, amount):
        return Account.withdraw(self, amount + self.withdraw_fee)
    def deposit_check(self, check):
        if check.payable_to == self.holder and check.amount &gt; 0:
            self.deposit(check.amount)
            check.amount = 0
            check.deposited = True
            return self.balance
        else:
            return 'The police have been notified.'

class Check(object):
    def __init__(self, payable_to, amount):
        self.payable_to = payable_to
        self.amount = amount
        self.deposited = False</code></pre>

<h3>Question 8</h3>
<pre><code>class Keyboard:
    """A Keyboard takes in an arbitrary amount of buttons, and has a
    dictionary of positions as keys, and values as Buttons.

    &gt;&gt;&gt; b1 = Button(0, "H")
    &gt;&gt;&gt; b2 = Button(1, "I")
    &gt;&gt;&gt; k = Keyboard(b1, b2)
    &gt;&gt;&gt; k.buttons[0].key
    'H'
    &gt;&gt;&gt; k.press(1)
    'I'
    &gt;&gt;&gt; k.typing([0, 1])
    'HI'
    &gt;&gt;&gt; k.typing([1, 0])
    'IH'
    &gt;&gt;&gt; b1.pressed
    2
    &gt;&gt;&gt; b2.pressed
    3
    """

    def __init__(self, *args):
        self.buttons = {b.pos: b for b in args}

    def press(self, info):
        """Takes in a position of the button pressed, and
        returns that button's output"""
        if info in self.buttons.keys():
            self.buttons[info].pressed += 1
            return self.buttons[info].key
        return ''

    def typing(self, typing_input):
        """Takes in a list of positions of buttons pressed, and
        returns the total output"""
        accumulate = ''
        for pos in typing_input:
            accumulate+=self.press(pos)
        return accumulate
        


class Button:
    def __init__(self, pos, key):
        self.pos = pos
        self.key = key
        self.pressed = 0
</code></pre>
:ET